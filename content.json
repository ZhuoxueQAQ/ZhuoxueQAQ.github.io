{"meta":{"title":"ZhuoxueQAQ的个人博客","subtitle":"","description":"相顾亦无言，唯有千行泪","author":"Zhuoxue","url":"https://zhuoxueqaq.github.io","root":"/"},"pages":[{"title":"404","date":"2020-08-29T03:42:21.000Z","updated":"2020-08-29T03:43:11.695Z","comments":true,"path":"404/index.html","permalink":"https://zhuoxueqaq.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-08-29T05:59:27.000Z","updated":"2020-08-29T06:18:16.669Z","comments":true,"path":"about/index.html","permalink":"https://zhuoxueqaq.github.io/about/index.html","excerpt":"","text":"准研一学生党，入坑前端开发，媚宅二刺猿 联系方式：&#x37;&#x38;&#52;&#55;&#x35;&#x34;&#52;&#x31;&#55;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;"},{"title":"archives","date":"2020-08-29T05:58:12.000Z","updated":"2020-08-29T05:58:31.773Z","comments":true,"path":"archives/index.html","permalink":"https://zhuoxueqaq.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-29T03:29:39.000Z","updated":"2020-08-29T05:50:37.662Z","comments":true,"path":"categories/index.html","permalink":"https://zhuoxueqaq.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-29T03:30:30.000Z","updated":"2020-08-29T03:33:14.406Z","comments":true,"path":"tags/index.html","permalink":"https://zhuoxueqaq.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Typescript开发环境搭建","slug":"Typescript开发环境搭建","date":"2020-08-31T12:36:38.000Z","updated":"2020-08-31T16:43:07.917Z","comments":true,"path":"2020/08/31/Typescript开发环境搭建/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/31/Typescript%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"打开vscode，进入待创建项目的根目录文件夹，在vscode的终端进行操作 使用npm初始化项目，生成package.json文件 1npm init -y 全局安装typescript 1npm install typescript -g 初始化，生成tsconfig.json文件 1tsc --init 根目录下创建src文件夹，在src下创建index.ts，并编译 1tsc ./src/index.ts 使用webpack工具。安装依赖包： 1npm i webpack webpack-cli webpack-dev-server -D 在配置webpack时，要区分开发环境和生产环境，为了让项目便于维护，可以开发环境配置、生产环境配置和公共配置分开书写，最后通过插件合并 在根目录下创建build文件夹，存放所有的配置文件，创建四个配置文件：webpack.base.config.js,webpack.config.js,webpack.dev.config.js,webpack.pro.config.js 编写开发环境配置文件webpack.base.config.js 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#x27;./src/index.ts&#x27;, output: &#123; filename: &#x27;app.js&#x27; &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;] &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/i, use: [&#123; loader: &#x27;ts-loader&#x27; &#125;], exclude: /node_modules/ &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/tpl/index.html&#x27; &#125;) ]&#125; 其中entry为项目的入口文件，output为输出文件，resolve代表可支持的文件拓展名。module规定了对指定后缀文件的处理方法，其中test用正则表达式匹配文件后缀，loader则是webpack加载各种资源文件使用的加载器，exclude则是排除指定目录的文件。插件HtmlWebpackPlugin可以帮我们生成网站的首页 接下来安装配置文件中相关依赖： 1npm install ts-loader typescript html-webpack-plugin -D 然后编写index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写开发环境配置文件webpack.dev.config.js: 123module.exports = &#123; devtool: &#x27;cheap-module-eval-source-map&#x27;&#125; 编写生产环境配置文件webpack.pro.config.js： 1234567const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123; plugins: [ new CleanWebpackPlugin() ]&#125; 并安装依赖包，这个包可以在每次成功构建项目之后清除一些无用的文件 1npm i clean-webpack-plugin -D 编写所有配置文件的入口配置文件webpack.config.js 123456const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)const baseConfig = require(&#x27;./webpack.base.config&#x27;)const devConfig = require(&#x27;./webpack.dev.config&#x27;)const proConfig = require(&#x27;./webpack.pro.config&#x27;)let config = process.NODE_ENV === &#x27;development&#x27; ? devConfig : proConfigmodule.exports = merge(baseConfig, config) 这里需要用npm安装插件webpack-merge，作用是把两个插件合并。该文件首先引入三个配置文件，然后定义变量config判断当前的环境变量，若是开发环境就选择开发环境配置，否则选择生产环境配置，最后合并配置文件 修改npm脚本文件package.json，如下： 123456789101112131415161718192021222324&#123; &quot;name&quot;: &quot;typescript_learning&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;./src/index.ts&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --mode=development --config ./build/webpack.config.js&quot;, &quot;build&quot;: &quot;webpack --mode=production --config ./build/webpack.config.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;clean-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^4.4.1&quot;, &quot;ts-loader&quot;: &quot;^8.0.3&quot;, &quot;typescript&quot;: &quot;^4.0.2&quot;, &quot;webpack&quot;: &quot;^4.44.1&quot;, &quot;webpack-cli&quot;: &quot;^3.3.12&quot;, &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot;, &quot;webpack-merge&quot;: &quot;^5.1.3&quot; &#125;&#125; 这里首先修改了name，令其不等于typescript，否则编译出错；接下来修改项目入口main；然后编写启动开发环境的命令start：使用webpack-dev-server 并指定为development开发模式，再指明配置文件目录； 然后就可以启动本地项目了： 123456npm start...i ｢wdm｣: Compiled successfully.i ｢wdm｣: Compiling...Version: webpack 4.44.1显示如下即编译成功，然后就可以在本地8080端口查看页面index.html了 接下来使用webpack编写构建生产环境的命令build 然后运行 1npn run build 打包以后，index.ts的内容会被整合到app.js中，并且会在index.html里引入app.js 到此基本结束。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript接口","slug":"Typescript接口","date":"2020-08-30T10:24:58.000Z","updated":"2020-08-31T11:21:24.161Z","comments":true,"path":"2020/08/30/Typescript接口/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/30/Typescript%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。 接口实例12345678910111213interface User &#123; userName: string, passWord: string&#125;function printUser(UserObj: User) &#123; let userMessege: string = `username: $&#123;UserObj.userName&#125;, password: $&#123;UserObj.passWord&#125;`; alert(userMessege);&#125;let myUser = &#123; userName: &#x27;zhuoxue&#x27;, passWord: &#x27;123&#x27;&#125;printUser(myUser); 可选接口 用？表示，代表实例化时该属性可传可不传 1234567891011121314151617interface User &#123; userName: string, passWord: string, age?: number&#125;function printUser(UserObj: User) &#123; let userMessege: string = `username: $&#123;UserObj.userName&#125;, password: $&#123;UserObj.passWord&#125;`; if(UserObj.age)&#123; userMessege += `, age:$&#123;UserObj.age&#125;`; &#125; alert(userMessege);&#125;let myUser = &#123; userName: &#x27;zhuoxue&#x27;, passWord: &#x27;123&#x27;&#125;printUser(myUser); 接口的只读属性（Readonly properties） readonly声明为只读。只读属性只能在初次实例化的时候传值，此后不能修改 123456interface Point &#123; readonly x: number, readonly y: number&#125;let p1: Point = &#123;x:10, y:10&#125;;p1.x = 15; // Cannot assign to &#x27;x&#x27; because it is a read-only property. 此外，Typescript拥有只读数组类型ReadonlyArray，该数组初始化后无法进行修改。可以使用普通数组来初始化只读数组，反之则不能，但可以使用type assertion操作来进行反向覆盖 123456let a: number[] = [1,2,3,4];let b: ReadonlyArray&lt;number&gt; = a;a = b; // The type &#x27;readonly number[]&#x27; is &#x27;readonly&#x27; and cannot be assigned to the mutable type &#x27;number[]&#x27;a[0] = 12;b[0] = 12; // Index signature in type &#x27;readonly number[]&#x27; only permits reading.a = b as number[] //type assertion Readonly和const 作用相似，使用场景不同。一般来说声明变量时使用const，而声明属性时用readonly 用接口描述函数类型下面是一个实例，类似于一个只有参数列表和返回值的函数声明。 接下来可以创建函数类型的变量，并分配对应类型的函数值，相应的值的参数列表和返回值需要一致，而参数名可不同 123456789101112131415interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string): boolean &#123; return src.search(subString)&gt;-1;&#125;// 也可mySearch = function(src: string, sub: string): boolean &#123; return src.search(sub)&gt;-1;&#125;// 返回值类型不同，报错mySearch = function(src: string, sub: string): boolean &#123; return src.search(sub); // Type &#x27;(src: string, sub: string) =&gt; string&#x27; is not assignable to type &#x27;SearchFunc&#x27;. Type &#x27;string&#x27; is not assignable to type &#x27;boolean&#x27;.&#125; 可索引类型（Indexable Types）有时我们想让我们对象支持向数组那样按照数字下标来存取数据，有时我们会想创建一个”字典”对象来存取任意的 “key/value” 对应关系。这两种情况就需要声明索引类型。区别在于索引本身的类型是数字还是字符串。 1234567891011121314interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray = [&quot;zhuoxue&quot;, &quot;qaq&quot;];let myStr: string = myArray[0];interface UserMap &#123; [index: string]: string;&#125;let myUserMap: UserMap = &#123; &quot;zhuoxue&quot;: &#x27;123&#x27;, &quot;qaq&quot;: &#x27;123&#x27;&#125;let pwd1: string = myUserMap[&#x27;zhuoxue&#x27;]; 可以同时支持两种索引，但是字符串索引对应值的类型必须是数字索引对应值的超集 123456789101112131415interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;interface NotOkay &#123; [x: number]: Animal, // Numeric index type &#x27;Animal&#x27; is not assignable to string index type &#x27;Dog&#x27;. [x: string]: Dog&#125;interface Okay &#123; [x: number]: string, [x: string]: string&#125; 此外，也可以将索引签名声明为只读，防止对应的值被修改。 类类型（Class Types）接口实现接口最常见的用法之一就是用来显式的约束类以满足特定的协定。 1234567interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); constructor(h: number, m: number) &#123;&#125;&#125; 此外，我们可以描述用类实现的接口中的方法 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125;","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"TypeScript函数","slug":"TypeScript函数","date":"2020-08-29T10:18:01.000Z","updated":"2020-08-29T15:25:45.562Z","comments":true,"path":"2020/08/29/TypeScript函数/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/29/TypeScript%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数——定义函数12345function getPassword(userName: string): string &#123; // 语句 return password;&#125;let pwd: string = getPassword(&#x27;zhuoxue&#x27;); 和js不同，ts函数的形参要指定类型，且实参和形参要一一对应 函数——可选参数和默认参数12345678// 可选参数,调用时对应实参可传可不传function getPassword(userName?: string): string &#123; //&#125;// 默认参数，更常用function setPassword(userName: string, passWord: string=&#x27;123456&#x27;): void&#123; //&#125; 函数——剩余参数12345678function add(a: number, b: number, ...c: number[]): void &#123; let resNum: number = a + b; for (let num of c) &#123; resNum += num; &#125; alert(resNum);&#125;add(1, 2, 3, 4, 5, 65, 7); 剩余参数需排在参数列表的最后，且必须为数组","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"TypeScript基本数据类型","slug":"ts基本数据类型","date":"2020-08-28T12:48:16.000Z","updated":"2020-09-01T15:43:17.605Z","comments":true,"path":"2020/08/28/ts基本数据类型/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/28/ts%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"变量 定义变量 1let userName:string = &#x27;zhuoxue&#x27;; 在ts中，对指定了类型的变量只能设置相同类型的值，和js不同 12let userName:string = &#x27;zhuoxue&#x27;;userName = 233; //类型非法 常用数据类型 字符串 1let userName: string = &#x27;zhuoxue&#x27;; 模板字符串 123let fullName: string = `zhuoxue`;let age: number = 21;let sentence: string = `My name is $&#123;fullName&#125;. I&#x27;m $&#123;age&#125; years old`; 模板字符串用反引号``表示，并且可以使用占位符${expr}进行嵌入 数值类型 12let testCount: number = 123;testCount = 123.45; 布尔型 123let isUser: boolean = true;isUser = false;// 要注意的是ts不能像js一样把true等价为1，false等价为0 undefined和null 数组 123456// 方式1let userList: string[] = [&#x27;qqq&#x27;,&#x27;www&#x27;];// 方式2：泛型语法let userList: Array&lt;string&gt; = [&#x27;qaq&#x27;,&#x27;qwq&#x27;];// 与js不同，ts定义数组要指定其中元素的数据类型，里面只能放相同类型的元素// 数组长度没有限制 元组 123let tup1: [string, number, bollean] = [&#x27;喜欢&#x27;, 520, true];alert(tup1[0]);console.log(tup1.length); 枚举 12345678910111213enum GunType &#123; m416 = 1, ak47 = 2, goza = 3&#125;// 默认枚举值从0开始enum GunType &#123; m416, //0 ak47, //1 goza //2&#125;// 使用枚举对象let userGun: GunType = GunType.m416; any any代表任意类型，一般在获取dom时使用。此外，接受用户输入或者第三方代码库时，尚未确定返回什么类型的值，也可使用any类型 12// 示例let txtName: any = document.getElementById(&#x27;txtN&#x27;); any类型牺牲了类型安全性换来了便捷性，而类型安全是typescript的一个主要特点，因此在不必要时应避免使用any void 无类型，一般在无返回值的函数中使用 never 不存在的值的类型，常用作为抛出异常或者无限循环的函数的返回类型 12345678function test():never &#123; while(true)&#123; &#125;&#125;function test1():never &#123; throw new Error(&#x27;error&#x27;);&#125; never类型为ts中的底部类型，所有类型都是never类型的父类，所以never类型值可以赋给任意类型的变量 类型断言可以把类型断言理解成”强制类型转换”。看下面这个例子 1234567const getLength = (target: string | number) =&gt; &#123; if (target.length || target.length === 0) &#123; return target.length &#125; else &#123; return target.toString.length &#125;&#125; 这个函数的输入为字符串或数字，若输入字符串则返回字符串长度，若输入数字则先转换为字符串再返回长度，但是由于数字不存在属性length，故该代码会报错。解决办法为使用类型断言： 12345678const getLength = (target: string | number) =&gt; &#123; // 类型断言的两种写法，在jss中只能使用第二种写法 if ((&lt;string&gt;target).length || (target as string).length === 0) &#123; return (&lt;string&gt;target).length &#125; else &#123; return target.toString.length &#125; &#125; 联合类型表示变量的取值可以为多种类型中的一种 12let userName: string | null = prompt(&#x27;input username:&#x27;);console.log(&#x27;hello&#x27; + userName); 关于let和const在ES6之前，一般用var来声明变量。由于JS只有函数作用于和全局作用域，没有块级作用域，所以&#123;&#125;限定不了var声明变量的访问范围。 let则可以声明块级作用域的变量，且let变量不存在变量提升（声明完才能使用），也不能重复声明。 123456&#123; var a = 1; let b = 1;&#125;console.log(a); // 1console.log(b); // Uncaught ReferenceError: i is not defined let相比var更安全可控 const是let的增强，使用const定义的变量不能再被赋值，但其定义变量的内部属性可以修改 1234567891011const user = &#123; name: &#x27;zhuoxue&#x27;, pwd: &#x27;123&#x27;&#125;// 错误user = &#123; name: &#x27;zhuoxueqaq&#x27;, pwd: &#x27;123456&#x27;&#125;// 正确user.name = &#x27;zhuoxueqaq&#x27;; 对不需要修改的变量建议用const let。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"使用hexo和github搭建博客","slug":"使用hexo和github搭建博客","date":"2020-08-28T06:33:43.000Z","updated":"2020-08-29T15:28:31.894Z","comments":true,"path":"2020/08/28/使用hexo和github搭建博客/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/28/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"安装和使用hexo安装hexo 安装node.js（内置npm） 全局安装cnpm： 1cnpm：npm install -g cnpm 安装hexo并验证安装： 12hexo：cnpm install -g hexohexo -v 使用hexo搭建博客 在目录文件夹git bash，并初始化hexo项目： 1hexo init 新建博客（新建的md文件存储在./source/_post下）： 1hexo n &quot;博客标题&quot; 生成hexo项目： 1hexo g 本地启动项目： 1hexo s 清空配置： 1hexo clean 将博客在github上部署建立github存储库 登录github账号，新建存储库。存储库名称为昵称.github.io 修改GitHub Pages配置，类型为master，并保存 选择任意主题即可 部署 修改项目根目录下的_config.yml文件中的Deployment选项： 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/ZhuoxueQAQ/ZhuoxueQAQ.github.io.git branch: master 要注意的是键的后面要有一个空格，否则无效 安装git部署插件： 1cnpm install --save hexo-deployer-git 安装完成后使用hexo清除历史配置，生成项目，并部署： 123hexo cleanhexo ghexo d 访问ZhuoxueQAQ.github.io即可。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhuoxueqaq.github.io/tags/hexo/"}]}],"categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"},{"name":"hexo","slug":"hexo","permalink":"https://zhuoxueqaq.github.io/tags/hexo/"}]}