{"meta":{"title":"ZhuoxueQAQ的个人博客","subtitle":"","description":"相顾亦无言，唯有千行泪","author":"Zhuoxue","url":"https://zhuoxueqaq.github.io","root":"/"},"pages":[{"title":"404","date":"2020-08-29T03:42:21.000Z","updated":"2020-08-29T03:43:11.695Z","comments":true,"path":"404/index.html","permalink":"https://zhuoxueqaq.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-08-29T05:59:27.000Z","updated":"2020-08-29T06:18:16.669Z","comments":true,"path":"about/index.html","permalink":"https://zhuoxueqaq.github.io/about/index.html","excerpt":"","text":"准研一学生党，入坑前端开发，媚宅二刺猿 联系方式：&#55;&#x38;&#x34;&#55;&#x35;&#52;&#x34;&#x31;&#x37;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;"},{"title":"archives","date":"2020-08-29T05:58:12.000Z","updated":"2020-08-29T05:58:31.773Z","comments":true,"path":"archives/index.html","permalink":"https://zhuoxueqaq.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-29T03:29:39.000Z","updated":"2020-08-29T05:50:37.662Z","comments":true,"path":"categories/index.html","permalink":"https://zhuoxueqaq.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-29T03:30:30.000Z","updated":"2020-08-29T03:33:14.406Z","comments":true,"path":"tags/index.html","permalink":"https://zhuoxueqaq.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"论文《Survey on WiFi-based indoor positioning techniques》阅读笔记","slug":"论文《Survey-on-WiFi-based-indoor-positioning-techniques》阅读笔记","date":"2020-09-17T08:15:50.000Z","updated":"2020-09-17T10:21:59.265Z","comments":true,"path":"2020/09/17/论文《Survey-on-WiFi-based-indoor-positioning-techniques》阅读笔记/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/17/%E8%AE%BA%E6%96%87%E3%80%8ASurvey-on-WiFi-based-indoor-positioning-techniques%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"该综述主要介绍基于WiFi的室内定位技术，并根据目标是否携带特定设备将其分成主动定位和被动定位，并详细比较了两种方法的应用场景和优缺点，最后展望了该技术的未来发展方向。","text":"该综述主要介绍基于WiFi的室内定位技术，并根据目标是否携带特定设备将其分成主动定位和被动定位，并详细比较了两种方法的应用场景和优缺点，最后展望了该技术的未来发展方向。 应用场景性能指标根据用户是否携带一定设备，我们将基于wifi的室内定位技术分为主动定位技术和被动定位技术： ) **主动定位（Active Positioning ）:**用户携带移动设备来动态的搜索和收集周围的信号。用户设备收集信息以后上传到服务器，服务器使用特定算法来定位用户。 被动定位（Passive Positioning）：用户不携带设备，但是需要在定位地点部署信号发送和接收设备。用户进入定位地点时会影响信号的传播。当用户在不同的位置是信号接收器会受到不同的信号，系统通过这些改变来定位用户。 动态定位相比于静态定位精度更高，但是需要用户携带额外设备。我们需要在不同的室内应用场景使用合适的室内定位技术。评估室内定位技术的性能主要有准确率，实时性，可拓展性，可靠性和开销等指标。 准确率（Accuracy）：acc是重点考虑因素之一，但是一个系统的总体性能还要考虑其他要素。在某些时候，过度追求acc会导致系统的其他指标下降。 实时性（Real-time） 可拓展性（Scalability）：系统在综合考虑性能、成本、可维护性等因素后对环境变化的适应能力。 **可靠性 (Reliability)**：在一个给定的时间和环境中，系统的反馈结果没有明显误差的概率 开销：考虑设备成本 挑战多路效应（Multipath effect）：wifi信号通过不同路径到达接收机时会产生多路效应。多路效应带来的信号失真会明显降低室内定位系统的精度 障碍物（Obstacle）：在实际场景中，障碍物如门，窗户，墙壁等的存在使信号的传输损耗难以估计，不同材质、结构的障碍物对信号传输损耗有不同影响。当wifi信号被障碍物阻碍时，基于某些特定算法的室内定位系统会出大问题。 设备异质性（Device heterogeneity:）设备异质性导致的接收信号强度（RSS）的差异会影响系统精度 主动定位技术主流，成果较多（手机行业快速发展，人人都有带wifi的手机）。","categories":[{"name":"论文笔记","slug":"论文笔记","permalink":"https://zhuoxueqaq.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"室内定位","slug":"室内定位","permalink":"https://zhuoxueqaq.github.io/tags/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D/"}]},{"title":"swift语法基础","slug":"swift语法基础","date":"2020-09-16T11:15:20.000Z","updated":"2020-09-16T13:48:24.331Z","comments":true,"path":"2020/09/16/swift语法基础/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/16/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"常量和变量12let constNumber = 100var variableNumber = 100 对不需要改变的值尽量声明为常量let 也可以使用类型注解： 1let constNumber:Int = 111 一般来说很少需要，swift可以在赋值的时候通过初值推断出常量或者变量的类型 输出常量和变量： 1234let constNumber:Int = 111print(constNumber)// 使用占位符print(&quot;const Number is \\(constNumber)&quot;) 基本数据类型整形整数类型包含默认整形Int以及无符号整形UInt**,少用UInt**。 整形有8,16,32,64位，一般来说不需要专门制定整形长度，用Int即可。 浮点型64位Double：高精度大存储 32位Float: 低精度小存储 都可以用的时候优先Float 布尔型12let orangesAreOrange = truelet turnipsAreDelicious = false 布尔类型不能使用非布尔值，否则报错 元组12let http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;) 可以把任意顺序、个数的类型组合成元组。 访问元组元素： 1234print(&quot;The status code is \\(http404Error.0)&quot;)// 输出“The status code is 404”print(&quot;The status message is \\(http404Error.1)&quot;)// 输出“The status message is Not Found” 定义元组的时候给单个元素命名： 1let http200Status = (statusCode: 200, description: &quot;OK&quot;) 作为函数返回值时，元组非常有用。","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"https://zhuoxueqaq.github.io/categories/IOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://zhuoxueqaq.github.io/tags/swift/"}]},{"title":"Typescript高级类型","slug":"Typescript高级类型","date":"2020-09-08T14:05:38.000Z","updated":"2020-09-09T13:52:39.006Z","comments":true,"path":"2020/09/08/Typescript高级类型/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/08/Typescript%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"交叉类型12345const mergeFunc = &lt;T, U&gt;(arg1: T, arg2: U): T &amp; U =&gt; &#123; let res = &#123;&#125; as T &amp; U res = Object.assign(arg1, arg2) return res&#125; 用 &amp; 声明，把多个类型合并成一个类型，合并后的类型同时有前面所有类型的成员 联合类型一般在函数参数中使用，比如要求某个参数可以是string和number类型，则可以声明为arg:string|number 类型保护1234567const getLength = (target: string | number) =&gt; &#123; if ((&lt;string&gt;target).length || (target as string).length === 0) &#123; return (&lt;string&gt;target).length &#125; else &#123; return target.toString.length &#125;&#125; 上面使用了类型断言，多次使用类型断言代码会变得较为复杂，可以使用类型保护简化。一旦检查过类型，就能在以后的每个分支清楚地知道变量的类型，比如下面的target 1234567891011// 定义函数实现类型保护function isString(value: string | number): value is string &#123; return typeof value === &#x27;string&#x27;&#125;const getLength = (target: string | number) =&gt; &#123; if (isString(target)) &#123; return target.length &#125; else &#123; return target.toString.length &#125;&#125; typeof类型保护将类型保护声明为函数较为复杂，Typescript中可以使用typeof关键字来检查类型： 1234567const getLength = (target: string | number) =&gt; &#123; if (typeof target === &#x27;string&#x27;) &#123; return target.length &#125; else if(typeof target !== &#x27;string&#x27;)&#123; return target.toString.length &#125;&#125; 这些* typeof类型保护*只有两种形式能被识别： typeof v === &quot;typename&quot;和 typeof v !== &quot;typename&quot;， 且&quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护，比如说： 12345678const getLength = (target: string | number) =&gt; &#123; if ((typeof target).includes(&#x27;string&#x27;)) &#123; // 类型“string | number”上不存在属性“length”。 return target.length &#125; else &#123; return target.toString.length &#125;&#125; 当target为字符串类型时，(typeof target).includes(&#39;string&#39;)返回true，但是typescript不会将其声明为类型保护 instanceof类型保护instanceof用来判断某个实例是不是某个类的实例 123456789101112131415class CreatedByClass1 &#123; public name: string = &#x27;zhuoxue&#x27;&#125;class CreatedByClass2 &#123; public age: number = 123&#125;function createClass() &#123; return Math.random() &lt; 0.5 ? new CreatedByClass1() : new CreatedByClass2()&#125;let item1 = createClass()if (item1 instanceof CreatedByClass1) &#123; console.log(item1.name)&#125; else &#123; console.log(item1.age)&#125; 可以为null的类型在默认情况下， null与 undefined可以赋值给任何类型，可以在配置文件中设置--strictNullChecks来开启严格检查，这样当声明一个变量时，它不再自动包含 null与 undefined类型，也可以手动指定包含null与 undefined的联合类型。需要注意的是 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数和可选属性在开启--strictNullChecks以后，可选参数和可选属性都会自动加上 | undefined 类型保护和类型断言由于可以为null的类型是通过联合类型实现，因此可以使用前面提到的类型保护和类型断言去除null。 123function f(sn: string | null): string &#123; return sn || &quot;default&quot;;&#125; 对于编译器无法识别的null，比如下面例子中的嵌套函数，可以使用类型断言手动指明某变量不为null： 12345678function getSplicedStr(num: number | null): string &#123; function getRes(prefix: string) &#123; // 这里用！或者？都可以，否则会由于num可能是null类型无法调用toFixed方法 return prefix + num!.toFixed.toString() &#125; num = num || 0.1 return getRes(&#x27;qaq&#x27;)&#125; 类型别名类型别名就是给一个类型起一个新名字，但是这不是创建一个新类型，比较类似于c++中的引用 12type TypeString = stringlet str1: TypeString = &#x27;qaq&#x27; 字面量类型字符串字面量类型使用字符串字面量类型可以让某字符串只能拥有固定的几个值。在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 123456type Direction = &#x27;north&#x27; | &#x27;east&#x27; | &#x27;south&#x27; | &#x27;west&#x27;function getDirectionFirstLetter(dir: Direction): string &#123; return dir.substring(0, 1)&#125;// 类型“&quot;qqq&quot;”的参数不能赋给类型“Direction”的参数。getDirectionFirstLetter(&#x27;qqq&#x27;) 数字字面量类型12345678910type Age = 1|2|3|4interface InfoInterface &#123; name: string age: Age&#125;const info1: InfoInterface = &#123; name: &#x27;qaq&#x27;, // 不能将类型“6”分配给类型“Age”。 age: 6&#125;","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript类","slug":"Typescript类","date":"2020-09-07T14:56:48.000Z","updated":"2020-09-09T14:07:21.473Z","comments":true,"path":"2020/09/07/Typescript类/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/07/Typescript%E7%B1%BB/","excerpt":"","text":"定义类123456789101112class Point&#123; public x: number public y: number constructor(x:number,y:number)&#123; this.x = x this.y = y &#125; printPoint() &#123; return `($&#123;this.x&#125;,$&#123;this.y&#125;)` &#125;&#125;let p1 = new Point(1,1) 其中constructor是构造函数，语法和c++,java都类似 类的继承1234567891011121314151617181920212223class Point&#123; public x: number public y: number constructor(x:number,y:number)&#123; this.x = x this.y = y &#125; printPoint() &#123; return `($&#123;this.x&#125;,$&#123;this.y&#125;)` &#125;&#125;class ThreeDPoint extends Point &#123; public z: number constructor(x:number,y:number,z:number) &#123; super(x,y) this.z = z &#125; printPoint() &#123; console.log(`($&#123;super.x&#125;,$&#123;super.y&#125;,$&#123;this.z&#125;)`) &#125;&#125;let p2 = new ThreeDPoint(1,1,1) 其中super指向其父类对象Point。声明子类的构造函数时，要先调用super()函数，可以理解成先调用父类的构造函数，然后再给子类新增成员初始化。 public，private和protected修饰符类似于c++等高级语言，typescript引入了这三个修饰符来规定成员的访问属性。 其中public表示该成员可以在类中，子类中以及类外自由访问。 private表示该成员为私有，只能在声明该成员的类中访问，无法在派生类类中（派生类类的构造函数可以初始化该成员，但是无法访问）以及类外访问 protected代表保护成员，保护成员可以在当前类以及派生类中访问（父类中需要继承给子类并使用的成员应声明为protected），类外无法访问 存取器在typescript中定义类时，可以定义get(设置属性值)和set(访问属性值)函数。 1234567891011121314151617class Point&#123; public x: number public y: number constructor(x:number,y:number)&#123; this.x = x this.y = y &#125; get nowPoint() &#123; return `($&#123;this.x&#125;,$&#123;this.y&#125;)` &#125; set changePoint(arg1:number,arg2:number) &#123; this.x = arg1 this.y = arg2 console.log(`($&#123;this.x&#125;,$&#123;this.y&#125;)`) &#125;&#125;let p1 = new Point(1,1) 静态属性typescript的静态属性和c++中类似，用static声明。静态成员和函数不属于实例化的某个对象，而是属于类本身。 1234567891011121314151617class User &#123; name: string password: string static count: number = 0 constructor(name: string, password: string) &#123; this.name = name this.password = password count += 1 &#125; static getUserCount &#123; rerturn User.count &#125;&#125;let user1 = new User(&#x27;123&#x27;,&#x27;123&#x27;)console.log(User.count)let user2 = new User(&#x27;123&#x27;,&#x27;123&#x27;)console.log(User.count) 抽象类抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法 12345678910111213141516abstract class User &#123; constructor(public name: string, public password: string) &#123; &#125; abstract printUserMessage(): void&#125;class Student extends User &#123; constructor(public name: string, public password: string, public type: string) &#123; super(name, password) &#125; printUserMessage() &#123; console.log(`User type: $&#123;this.type&#125;`) &#125;&#125;let s1 = new Student(&#x27;zhuoxue&#x27;, &#x27;123&#x27;, &#x27;student&#x27;)s1.printUserMessage() 在抽象基类的任意派生类中，从抽象基类继承的抽象方法必须重写","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript泛型","slug":"Typescript泛型","date":"2020-09-03T09:58:27.000Z","updated":"2020-09-03T14:01:25.983Z","comments":true,"path":"2020/09/03/Typescript泛型/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/03/Typescript%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 泛型的简单例子12345678910const getArray = &lt;T&gt;(value: T, times: number = 5): T[] =&gt; &#123; // 返回一个有times个值为value的数组 return new Array(times).fill(value)&#125;// map函数的作用是对数组中的每一个数据调用一个回调函数，并返回改变后的数组。这里把数组中所有元素变成字符串let arr = getArray&lt;number&gt;(123, 4).map((item) =&gt; item.toString())console.log(arr) 个人理解：泛型类似于c++中的函数模板 使用多个泛型参数1234567891011// 使用多个泛型参数const getArray1 = &lt;T, U&gt;(param1: T, param2: U, count: number): [T, U][] =&gt; &#123; return new Array(count).fill([param1, param2])&#125;let tup1 = getArray1(&#x27;user&#x27;, 123, 3)tup1.forEach((item) =&gt; &#123; console.log(item[0]) console.log(item[1])&#125;) 在类型别名中使用泛型1234type GetArray = &lt;T&gt;(arg: T, times: number) =&gt; T[]let getArray3: GetArray = (arg: any, times: number) =&gt; &#123; return new Array(times).fill(arg)&#125; 在接口中使用泛型1234interface GetArray&lt;T&gt; &#123; (arg: T, timea: number): T[], array: T[]&#125; 泛型约束简单来说，泛型约束就是让传入的泛型参数符合一定条件。 1234type GetLength = &lt;T&gt;(arg: T) =&gt; numberlet getLength = (arg: any) =&gt; &#123; return arg.length&#125; 上面的例子当传入没有length属性的例子时就会报错。为了限制函数处理任意带有length的属性，我们可以定义一个接口来描述该条件，并让泛型T继承该接口以满足约束 12345678interface ValueWithLength &#123; length: number&#125;type GetLength = &lt;T extends ValueWithLength&gt;(arg: T) =&gt; numberlet getLength = (arg: any) =&gt; &#123; return arg.length&#125; 在泛型约束中使用类型参数123456789101112const getProperty = &lt;T, K extends keyof T&gt;(Obj: T, key: K) =&gt; &#123; return Obj[key]&#125;const obj1 = &#123; a: &#x27;1&#x27;, b: &#x27;2&#x27;, c: &#x27;3&#x27;,&#125;getProperty(obj1, &#x27;d&#x27;) // 类型“&quot;d&quot;”的参数不能赋给类型“&quot;a&quot; | &quot;b&quot; | &quot;c&quot;”的参数。getProperty(obj1, &#x27;a&#x27;) // 1 在上面的例子中，当函数试图传入obj1不存在的索引时，会提示错误，保证当想从对象中获取某个属性对应的值时，该属性一定存在于对象中","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript开发环境搭建","slug":"Typescript开发环境搭建","date":"2020-08-31T12:36:38.000Z","updated":"2020-08-31T16:43:07.917Z","comments":true,"path":"2020/08/31/Typescript开发环境搭建/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/31/Typescript%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"打开vscode，进入待创建项目的根目录文件夹，在vscode的终端进行操作 使用npm初始化项目，生成package.json文件 1npm init -y 全局安装typescript 1npm install typescript -g 初始化，生成tsconfig.json文件 1tsc --init 根目录下创建src文件夹，在src下创建index.ts，并编译 1tsc ./src/index.ts 使用webpack工具。安装依赖包： 1npm i webpack webpack-cli webpack-dev-server -D 在配置webpack时，要区分开发环境和生产环境，为了让项目便于维护，可以开发环境配置、生产环境配置和公共配置分开书写，最后通过插件合并 在根目录下创建build文件夹，存放所有的配置文件，创建四个配置文件：webpack.base.config.js,webpack.config.js,webpack.dev.config.js,webpack.pro.config.js 编写开发环境配置文件webpack.base.config.js 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#x27;./src/index.ts&#x27;, output: &#123; filename: &#x27;app.js&#x27; &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;] &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/i, use: [&#123; loader: &#x27;ts-loader&#x27; &#125;], exclude: /node_modules/ &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/tpl/index.html&#x27; &#125;) ]&#125; 其中entry为项目的入口文件，output为输出文件，resolve代表可支持的文件拓展名。module规定了对指定后缀文件的处理方法，其中test用正则表达式匹配文件后缀，loader则是webpack加载各种资源文件使用的加载器，exclude则是排除指定目录的文件。插件HtmlWebpackPlugin可以帮我们生成网站的首页 接下来安装配置文件中相关依赖： 1npm install ts-loader typescript html-webpack-plugin -D 然后编写index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写开发环境配置文件webpack.dev.config.js: 123module.exports = &#123; devtool: &#x27;cheap-module-eval-source-map&#x27;&#125; 编写生产环境配置文件webpack.pro.config.js： 1234567const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123; plugins: [ new CleanWebpackPlugin() ]&#125; 并安装依赖包，这个包可以在每次成功构建项目之后清除一些无用的文件 1npm i clean-webpack-plugin -D 编写所有配置文件的入口配置文件webpack.config.js 123456const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)const baseConfig = require(&#x27;./webpack.base.config&#x27;)const devConfig = require(&#x27;./webpack.dev.config&#x27;)const proConfig = require(&#x27;./webpack.pro.config&#x27;)let config = process.NODE_ENV === &#x27;development&#x27; ? devConfig : proConfigmodule.exports = merge(baseConfig, config) 这里需要用npm安装插件webpack-merge，作用是把两个插件合并。该文件首先引入三个配置文件，然后定义变量config判断当前的环境变量，若是开发环境就选择开发环境配置，否则选择生产环境配置，最后合并配置文件 修改npm脚本文件package.json，如下： 123456789101112131415161718192021222324&#123; &quot;name&quot;: &quot;typescript_learning&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;./src/index.ts&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --mode=development --config ./build/webpack.config.js&quot;, &quot;build&quot;: &quot;webpack --mode=production --config ./build/webpack.config.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;clean-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^4.4.1&quot;, &quot;ts-loader&quot;: &quot;^8.0.3&quot;, &quot;typescript&quot;: &quot;^4.0.2&quot;, &quot;webpack&quot;: &quot;^4.44.1&quot;, &quot;webpack-cli&quot;: &quot;^3.3.12&quot;, &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot;, &quot;webpack-merge&quot;: &quot;^5.1.3&quot; &#125;&#125; 这里首先修改了name，令其不等于typescript，否则编译出错；接下来修改项目入口main；然后编写启动开发环境的命令start：使用webpack-dev-server 并指定为development开发模式，再指明配置文件目录； 然后就可以启动本地项目了： 123456npm start...i ｢wdm｣: Compiled successfully.i ｢wdm｣: Compiling...Version: webpack 4.44.1显示如下即编译成功，然后就可以在本地8080端口查看页面index.html了 接下来使用webpack编写构建生产环境的命令build 然后运行 1npn run build 打包以后，index.ts的内容会被整合到app.js中，并且会在index.html里引入app.js 到此基本结束。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript接口","slug":"Typescript接口","date":"2020-08-30T10:24:58.000Z","updated":"2020-08-31T11:21:24.161Z","comments":true,"path":"2020/08/30/Typescript接口/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/30/Typescript%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。 接口实例12345678910111213interface User &#123; userName: string, passWord: string&#125;function printUser(UserObj: User) &#123; let userMessege: string = `username: $&#123;UserObj.userName&#125;, password: $&#123;UserObj.passWord&#125;`; alert(userMessege);&#125;let myUser = &#123; userName: &#x27;zhuoxue&#x27;, passWord: &#x27;123&#x27;&#125;printUser(myUser); 可选接口 用？表示，代表实例化时该属性可传可不传 1234567891011121314151617interface User &#123; userName: string, passWord: string, age?: number&#125;function printUser(UserObj: User) &#123; let userMessege: string = `username: $&#123;UserObj.userName&#125;, password: $&#123;UserObj.passWord&#125;`; if(UserObj.age)&#123; userMessege += `, age:$&#123;UserObj.age&#125;`; &#125; alert(userMessege);&#125;let myUser = &#123; userName: &#x27;zhuoxue&#x27;, passWord: &#x27;123&#x27;&#125;printUser(myUser); 接口的只读属性（Readonly properties） readonly声明为只读。只读属性只能在初次实例化的时候传值，此后不能修改 123456interface Point &#123; readonly x: number, readonly y: number&#125;let p1: Point = &#123;x:10, y:10&#125;;p1.x = 15; // Cannot assign to &#x27;x&#x27; because it is a read-only property. 此外，Typescript拥有只读数组类型ReadonlyArray，该数组初始化后无法进行修改。可以使用普通数组来初始化只读数组，反之则不能，但可以使用type assertion操作来进行反向覆盖 123456let a: number[] = [1,2,3,4];let b: ReadonlyArray&lt;number&gt; = a;a = b; // The type &#x27;readonly number[]&#x27; is &#x27;readonly&#x27; and cannot be assigned to the mutable type &#x27;number[]&#x27;a[0] = 12;b[0] = 12; // Index signature in type &#x27;readonly number[]&#x27; only permits reading.a = b as number[] //type assertion Readonly和const 作用相似，使用场景不同。一般来说声明变量时使用const，而声明属性时用readonly 用接口描述函数类型下面是一个实例，类似于一个只有参数列表和返回值的函数声明。 接下来可以创建函数类型的变量，并分配对应类型的函数值，相应的值的参数列表和返回值需要一致，而参数名可不同 123456789101112131415interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string): boolean &#123; return src.search(subString)&gt;-1;&#125;// 也可mySearch = function(src: string, sub: string): boolean &#123; return src.search(sub)&gt;-1;&#125;// 返回值类型不同，报错mySearch = function(src: string, sub: string): boolean &#123; return src.search(sub); // Type &#x27;(src: string, sub: string) =&gt; string&#x27; is not assignable to type &#x27;SearchFunc&#x27;. Type &#x27;string&#x27; is not assignable to type &#x27;boolean&#x27;.&#125; 可索引类型（Indexable Types）有时我们想让我们对象支持向数组那样按照数字下标来存取数据，有时我们会想创建一个”字典”对象来存取任意的 “key/value” 对应关系。这两种情况就需要声明索引类型。区别在于索引本身的类型是数字还是字符串。 1234567891011121314interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray = [&quot;zhuoxue&quot;, &quot;qaq&quot;];let myStr: string = myArray[0];interface UserMap &#123; [index: string]: string;&#125;let myUserMap: UserMap = &#123; &quot;zhuoxue&quot;: &#x27;123&#x27;, &quot;qaq&quot;: &#x27;123&#x27;&#125;let pwd1: string = myUserMap[&#x27;zhuoxue&#x27;]; 可以同时支持两种索引，但是字符串索引对应值的类型必须是数字索引对应值的超集 123456789101112131415interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;interface NotOkay &#123; [x: number]: Animal, // Numeric index type &#x27;Animal&#x27; is not assignable to string index type &#x27;Dog&#x27;. [x: string]: Dog&#125;interface Okay &#123; [x: number]: string, [x: string]: string&#125; 此外，也可以将索引签名声明为只读，防止对应的值被修改。 类类型（Class Types）接口实现接口最常见的用法之一就是用来显式的约束类以满足特定的协定。 1234567interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); constructor(h: number, m: number) &#123;&#125;&#125; 此外，我们可以描述用类实现的接口中的方法 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125;","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"TypeScript函数","slug":"TypeScript函数","date":"2020-08-29T10:18:01.000Z","updated":"2020-09-03T12:37:35.614Z","comments":true,"path":"2020/08/29/TypeScript函数/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/29/TypeScript%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数——定义函数12345function getPassword(userName: string): string &#123; // 语句 return password;&#125;let pwd: string = getPassword(&#x27;zhuoxue&#x27;); 和js不同，ts函数的形参要指定类型，且实参和形参要一一对应 函数——可选参数和默认参数12345678// 可选参数,调用时对应实参可传可不传function getPassword(userName?: string): string &#123; //&#125;// 默认参数，更常用function setPassword(userName: string, passWord: string=&#x27;123456&#x27;): void&#123; //&#125; 理解类型别名12type isString = stringlet str: isString = &#x27;zhuoxueqaq&#x27; 使用类型别名定义函数类型12type Add = (x: number, y: number) =&gt; numberlet add4: Add = (arg1: number, arg2: number) =&gt; arg1 + arg2 函数——剩余参数12345678function add(a: number, b: number, ...c: number[]): void &#123; let resNum: number = a + b; for (let num of c) &#123; resNum += num; &#125; alert(resNum);&#125;add(1, 2, 3, 4, 5, 65, 7); 剩余参数需排在参数列表的最后，且必须为数组 函数重载123456789101112// 声明方法重载的定义，不实现function handleData(x: string): string[]function handleData(x: number): number[]// 声明一个any类型的重载定义，并根据具体参数和返回类型来实现方法function handleData(x: any): any &#123; if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;) &#125; else &#123; return x.toString().split(&#x27;&#x27;).map((item: any) =&gt; Number(item)) &#125;&#125;console.log(handleData(123))","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"TypeScript基本数据类型","slug":"ts基本数据类型","date":"2020-08-28T12:48:16.000Z","updated":"2020-09-09T08:25:45.139Z","comments":true,"path":"2020/08/28/ts基本数据类型/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/28/ts%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"变量 定义变量 1let userName:string = &#x27;zhuoxue&#x27;; 在ts中，对指定了类型的变量只能设置相同类型的值，和js不同 12let userName:string = &#x27;zhuoxue&#x27;;userName = 233; //类型非法 常用数据类型 字符串 1let userName: string = &#x27;zhuoxue&#x27;; 模板字符串 123let fullName: string = `zhuoxue`;let age: number = 21;let sentence: string = `My name is $&#123;fullName&#125;. I&#x27;m $&#123;age&#125; years old`; 模板字符串用反引号``表示，并且可以使用占位符${expr}进行嵌入 数值类型 12let testCount: number = 123;testCount = 123.45; 布尔型 123let isUser: boolean = true;isUser = false;// 要注意的是ts不能像js一样把true等价为1，false等价为0 undefined和null 数组 123456// 方式1let userList: string[] = [&#x27;qqq&#x27;,&#x27;www&#x27;];// 方式2：泛型语法let userList: Array&lt;string&gt; = [&#x27;qaq&#x27;,&#x27;qwq&#x27;];// 与js不同，ts定义数组要指定其中元素的数据类型，里面只能放相同类型的元素// 数组长度没有限制 元组 123let tup1: [string, number, bollean] = [&#x27;喜欢&#x27;, 520, true];alert(tup1[0]);console.log(tup1.length); 枚举 123456789101112131415161718192021222324252627enum GunType &#123; m416 = 1, ak47 = 2, goza = 3&#125;// 默认枚举值从0开始enum GunType &#123; m416, //0 ak47, //1 goza //2&#125;// 使用枚举对象let userGun: GunType = GunType.m416;// 字符串枚举enum Message &#123; Error =&#x27;error&#x27;, Success = &#x27;success&#x27;, Failed = Error,&#125;// 异构枚举enum Result &#123; Error = 0, Success = &#x27;success&#x27;,&#125; any any代表任意类型，一般在获取dom时使用。此外，接受用户输入或者第三方代码库时，尚未确定返回什么类型的值，也可使用any类型 12// 示例let txtName: any = document.getElementById(&#x27;txtN&#x27;); any类型牺牲了类型安全性换来了便捷性，而类型安全是typescript的一个主要特点，因此在不必要时应避免使用any void 无类型，一般在无返回值的函数中使用 never 不存在的值的类型，常用作为抛出异常或者无限循环的函数的返回类型 12345678function test():never &#123; while(true)&#123; &#125;&#125;function test1():never &#123; throw new Error(&#x27;error&#x27;);&#125; never类型为ts中的底部类型，所有类型都是never类型的父类，所以never类型值可以赋给任意类型的变量 类型断言1234567const getLength = (target: string | number) =&gt; &#123; if (target.length || target.length === 0) &#123; return target.length &#125; else &#123; return target.toString.length &#125;&#125; 上面的代码会报错，因为当target为数字时，数字是没有长度属性的，可以使用类型断言解决这个问题 123456789const getLength = (target: string | number) =&gt; &#123; // 类型断言的两种写法，在jss中只能使用第二种写法 if ((&lt;string&gt;target).length || (target as string).length === 0) &#123; return (&lt;string&gt;target).length &#125; else &#123; return target.toString.length &#125; &#125; 表示变量的取值可以为多种类型中的一种 12let userName: string | null = prompt(&#x27;input username:&#x27;);console.log(&#x27;hello&#x27; + userName); 关于let和const 在ES6之前，一般用var来声明变量。由于JS只有函数作用于和全局作用域，没有块级作用域，所以&#123;&#125;限定不了var声明变量的访问范围。 let则可以声明块级作用域的变量，且let变量不存在变量提升（声明完才能使用），也不能重复声明。 123456&#123; var a = 1; let b = 1;&#125;console.log(a); // 1console.log(b); // Uncaught ReferenceError: i is not defined let相比var更安全可控 const是let的增强，使用const定义的变量不能再被赋值，但其定义变量的内部属性可以修改 1234567891011const user = &#123; name: &#x27;zhuoxue&#x27;, pwd: &#x27;123&#x27;&#125;// 错误user = &#123; name: &#x27;zhuoxueqaq&#x27;, pwd: &#x27;123456&#x27;&#125;// 正确user.name = &#x27;zhuoxueqaq&#x27;; 对不需要修改的变量建议用const let。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"使用hexo和github搭建博客","slug":"使用hexo和github搭建博客","date":"2020-08-28T06:33:43.000Z","updated":"2020-08-29T15:28:31.894Z","comments":true,"path":"2020/08/28/使用hexo和github搭建博客/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/28/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"安装和使用hexo安装hexo 安装node.js（内置npm） 全局安装cnpm： 1cnpm：npm install -g cnpm 安装hexo并验证安装： 12hexo：cnpm install -g hexohexo -v 使用hexo搭建博客 在目录文件夹git bash，并初始化hexo项目： 1hexo init 新建博客（新建的md文件存储在./source/_post下）： 1hexo n &quot;博客标题&quot; 生成hexo项目： 1hexo g 本地启动项目： 1hexo s 清空配置： 1hexo clean 将博客在github上部署建立github存储库 登录github账号，新建存储库。存储库名称为昵称.github.io 修改GitHub Pages配置，类型为master，并保存 选择任意主题即可 部署 修改项目根目录下的_config.yml文件中的Deployment选项： 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/ZhuoxueQAQ/ZhuoxueQAQ.github.io.git branch: master 要注意的是键的后面要有一个空格，否则无效 安装git部署插件： 1cnpm install --save hexo-deployer-git 安装完成后使用hexo清除历史配置，生成项目，并部署： 123hexo cleanhexo ghexo d 访问ZhuoxueQAQ.github.io即可。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhuoxueqaq.github.io/tags/hexo/"}]}],"categories":[{"name":"论文笔记","slug":"论文笔记","permalink":"https://zhuoxueqaq.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"IOS开发","slug":"IOS开发","permalink":"https://zhuoxueqaq.github.io/categories/IOS%E5%BC%80%E5%8F%91/"},{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"室内定位","slug":"室内定位","permalink":"https://zhuoxueqaq.github.io/tags/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D/"},{"name":"swift","slug":"swift","permalink":"https://zhuoxueqaq.github.io/tags/swift/"},{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"},{"name":"hexo","slug":"hexo","permalink":"https://zhuoxueqaq.github.io/tags/hexo/"}]}