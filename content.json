{"meta":{"title":"ZhuoxueQAQ的个人博客","subtitle":"","description":"相顾亦无言，唯有千行泪","author":"Zhuoxue","url":"https://zhuoxueqaq.github.io","root":"/"},"pages":[{"title":"404","date":"2020-08-29T03:42:21.000Z","updated":"2020-08-29T03:43:11.695Z","comments":true,"path":"404/index.html","permalink":"https://zhuoxueqaq.github.io/404/index.html","excerpt":"","text":""},{"title":"about","date":"2020-08-29T05:59:27.000Z","updated":"2020-08-29T06:18:16.669Z","comments":true,"path":"about/index.html","permalink":"https://zhuoxueqaq.github.io/about/index.html","excerpt":"","text":"准研一学生党，入坑前端开发，媚宅二刺猿 联系方式：&#55;&#x38;&#x34;&#55;&#x35;&#52;&#x34;&#x31;&#x37;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;"},{"title":"archives","date":"2020-08-29T05:58:12.000Z","updated":"2020-08-29T05:58:31.773Z","comments":true,"path":"archives/index.html","permalink":"https://zhuoxueqaq.github.io/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-29T03:29:39.000Z","updated":"2020-08-29T05:50:37.662Z","comments":true,"path":"categories/index.html","permalink":"https://zhuoxueqaq.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-29T03:30:30.000Z","updated":"2020-08-29T03:33:14.406Z","comments":true,"path":"tags/index.html","permalink":"https://zhuoxueqaq.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ios程序设计6讲","slug":"ios程序设计6讲","date":"2020-11-29T02:39:37.000Z","updated":"2020-11-29T13:14:46.932Z","comments":true,"path":"2020/11/29/ios程序设计6讲/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/11/29/ios%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E8%AE%B2/","excerpt":"","text":"UINavigationController正向导航并传递数据 插入3个ViewController: ViewController, RedController和BlueController。 分别建立对应的ViewController文件，并在storybroad中的show the inentity inspector中对应每个文件和storybroad中的每个视图 在editor-&gt;assistance选中，保证点击每个view时显示对应代码 每个view加一个button，选中对应的button按ctrl键，然后鼠标移到目标view后，在弹出的选项选择show 修改源视图的prepare方法（举例说明）： 1234override func prepare(for segue: UIStoryboardSegue, sender: Any?)&#123; let redView = segue.destination as! RedViewController redView.redViewData = &quot;1232324&quot;&#125; 修改目标视图的ViewDidLoad(),该方法会在视图加载到内存但未显示时调用 12345override func viewDidLoad()&#123; super.viewDidLoad() // show the data from source view self.title = self.redViewData&#125; 完成 逆向导航并传递数据 在源视图的prepare方法中处理好要传输的数据，该方法会在视图切换前调用 12345678910class BlueViewController: UIViewController&#123; var blueViewData:String? //要传输的数据 override func ViewDidLoad()&#123; super.viewDidLoad() // ... &#125; override func prepare()&#123; self.blueViewData = &quot;qwewrfdwieu&quot; &#125;&#125; 在目的视图新建一个方法（若无需传数据只跳转该函数体可为空）： 123456@IBAction func unwindFromBlueViewToRoot(segue:UIStoryboardSegue)&#123; // 获取源视图 let blueView = segue.scoure as! BlueViewController // 从源视图获取并显示数据 self.title = blueView.blueViewData&#125; 在storybroad中，选择源视图的某个触视图跳转的按钮，按住ctrl并将鼠标移到目的视图的exit部分，在弹出的选项中选择刚刚新建的方法 可以了","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"https://zhuoxueqaq.github.io/categories/IOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://zhuoxueqaq.github.io/tags/swift/"}]},{"title":"swift字符串","slug":"swift字符串","date":"2020-09-17T12:04:28.000Z","updated":"2020-09-17T13:21:38.905Z","comments":true,"path":"2020/09/17/swift字符串/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/17/swift%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"访问和修改字符串字符串索引在swift中不同的字符占有的内存空间不一定相同，不能使用整数来做字符串的索引。 使用 startIndex 属性可以获取一个 String 的第一个 Character 的索引。使用 endIndex 属性可以获取最后一个 Character 的后一个位置的索引。因此，endIndex 属性不能作为一个字符串的有效下标。如果 String 是空串，startIndex 和 endIndex 是相等的。 通过调用 String 的 index(before:) 或 index(after:) 方法，可以立即得到前面或后面的一个索引。你还可以通过调用 index(_:offsetBy:) 方法来获取对应偏移量的索引，这种方式可以避免多次调用 index(before:) 或 index(after:) 方法。 12345let str1 = &quot;qwerty&quot;print(str1[str1.startIndex])print(str1[str1.index(after:str1.startIndex)])print(str1[str1.index(str1.startIndex, offsetBy: 3)])print(str1[str1.index(str1.endIndex, offsetBy: -1)]) 使用indices遍历字符串: 123for index in str1.indices &#123; print(&quot;\\(str1[index])&quot;, terminator: &quot; &quot;)&#125; 插入和删除调用 insert(_:at:) 方法可以在一个字符串的指定索引插入一个字符，调用 insert(contentsOf:at:) 方法可以在一个字符串的指定索引插入一个段字符串。 1234let str1 = &quot;qwerty&quot;str1.insert(&quot;u&quot;, at: str1.index(before: str1.endIndex))str1.insert(contentsOf: &quot;qaq&quot;, at: str1.index(str1.endIndex, offsetBy: 0))print(str1) 子字符串12345678let greeting = &quot;Hello, world!&quot;let index = greeting.index(str1.startIndex, offsetBy: 5) ?? greeting.endIndexlet beginning = greeting[..&lt;index]// beginning 的值为 &quot;Hello&quot;// 把结果转化为 String 以便长期存储。let newString = String(beginning)print(newString) 其中beginning是字符串greeting的子字符串substring，子字符串的内存空间在原字符串中。而newString是新的字符串对象，占有不同的内存空间 比较字符串相等或不等使用==和!=运算符 判断前缀/后缀通过调用字符串的 hasPrefix(_:)/hasSuffix(_:) 方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个 String 类型的参数，并返回一个布尔值。 1234567891011121314import Foundationlet strList = [ &quot;str1: qaq&quot;, &quot;str1: qwq&quot;, &quot;str2: qaz&quot;, &quot;str3: qwe&quot;]for str in strList &#123; if str.hasPrefix(&quot;str1&quot;)&#123; print(str) &#125;else if str.hasSuffix(&quot;qwe&quot;)&#123; print(str) &#125;&#125;","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"https://zhuoxueqaq.github.io/categories/IOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://zhuoxueqaq.github.io/tags/swift/"}]},{"title":"论文《Survey on WiFi-based indoor positioning techniques》阅读笔记","slug":"论文《Survey-on-WiFi-based-indoor-positioning-techniques》阅读笔记","date":"2020-09-17T08:15:50.000Z","updated":"2020-09-23T10:55:20.630Z","comments":true,"path":"2020/09/17/论文《Survey-on-WiFi-based-indoor-positioning-techniques》阅读笔记/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/17/%E8%AE%BA%E6%96%87%E3%80%8ASurvey-on-WiFi-based-indoor-positioning-techniques%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"该综述主要介绍基于WiFi的室内定位技术，并根据目标是否携带特定设备将其分成主动定位和被动定位，并详细比较了两种方法的应用场景和优缺点，最后展望了该技术的未来发展方向。","text":"该综述主要介绍基于WiFi的室内定位技术，并根据目标是否携带特定设备将其分成主动定位和被动定位，并详细比较了两种方法的应用场景和优缺点，最后展望了该技术的未来发展方向。 应用场景性能指标根据用户是否携带一定设备，我们将基于wifi的室内定位技术分为主动定位技术和被动定位技术： **主动定位（Active Positioning ）:**用户携带移动设备来动态的搜索和收集周围的信号。用户设备收集信息以后上传到服务器，服务器使用特定算法来定位用户。 被动定位（Passive Positioning）：用户不携带设备，但是需要在定位地点部署信号发送和接收设备。用户进入定位地点时会影响信号的传播。当用户在不同的位置是信号接收器会受到不同的信号，系统通过这些改变来定位用户。 动态定位相比于静态定位精度更高，但是需要用户携带额外设备。我们需要在不同的室内应用场景使用合适的室内定位技术。评估室内定位技术的性能主要有准确率，实时性，可拓展性，可靠性和开销等指标。 准确率（Accuracy）：acc是重点考虑因素之一，但是一个系统的总体性能还要考虑其他要素。在某些时候，过度追求acc会导致系统的其他指标下降。 实时性（Real-time） 可拓展性（Scalability）：系统在综合考虑性能、成本、可维护性等因素后对环境变化的适应能力。 可靠性 (Reliability)：在一个给定的时间和环境中，系统的反馈结果没有明显误差的概率 开销：考虑设备成本 挑战多路效应（Multipath effect）：wifi信号通过不同路径到达接收机时会产生多路效应。多路效应带来的信号失真会明显降低室内定位系统的精度 障碍物（Obstacle）：在实际场景中，障碍物如门，窗户，墙壁等的存在使信号的传输损耗难以估计，不同材质、结构的障碍物对信号传输损耗有不同影响。当wifi信号被障碍物阻碍时，基于某些特定算法的室内定位系统会出大问题。 设备异质性（Device heterogeneity:）设备异质性导致的接收信号强度（RSS）的差异会影响系统精度 主动定位技术主流，成果较多（手机行业快速发展，人人都有带wifi的手机）。主要分为Range-Free和Range-Based两种。 Range-Free(非测距/指纹定位)指纹定位。分成离线和在线两个阶段： 离线阶段：对区域进行划分，在划分好的每个位置上采集指纹，建立指纹数据库 在线阶段：待定位设备进入区域时，采集目标的指纹特征并对比数据库估计目标位置 并不是传统意义上的指纹，而是指该位置的特征信息， 例如信号强度 RSSI 值、方向等特征都可以作为指纹的一部分 根据指纹数据库的构建方法和RSS处理方法，可以将基于智能手机的室内活动定位技术分为Deterministic technologies和probabilistic technologies。 Deterministic technologies将某个区域一段时间内采集的RSS的平均值作为位置指纹信息存到数据库。然后对比待定位目标的指纹和数据库中的指纹信息，最后使用某些定位算法来定位目标。 在离线和在线阶段的改进方法： 离线阶段： MPAD：一种AP部署算法，利用那些预先存在的AP来识别定位精度较差的候选位置，以部署新的AP； 让系统自动更新指纹数据库，减少人工介入 多径效应，环境影响等问题：使用地图覆盖技术估计目标位置 设备异质性：将WiFi RSSs转换为一种新型的标准位置指纹，提高系统鲁棒性 在线阶段：减少基于指纹的室内WiFi定位系统对无线电地图的依赖，以减少离线阶段现场调查的工作量。 probabilistic technologies计算复杂度更高，准确度也更高，对噪声有很好的鲁棒性 概率算法首先计算在固定位置接收到的每个AP的RSS概率分布函数，然后将这些分布函数合并为联合分布函数，并将联合分布函数作为位置指纹保存在数据库中。最后，当接收机的RSS为ri时，算法在数据库中搜索最可能的RSS为ri的位置。 Fusion technology手机上除了有wifi，还有蓝牙等模块。可以融合手机上的各种模块，或者融入其他设备。 wifi+计算机视觉（如手机摄像头） wifi+惯性导航（陀螺仪 加速度器） wifi+蓝牙 wifi+地磁： 地磁场广泛分布，不同位置的地磁场分布不同。 Ranged-basedTime of arrival (TOA)/time difference of arrival (TDOA):作为一种从信号到达时间中提取信息实现定位的方法，信号到达时延的估计是影响定位精度的主要因素。由于多径干扰、非视距、噪声和室内设备间的时间同步等因素，目前许多TOA或TDOA的研究都在存在问题的基础上提出了改进算法。 Angle of arrival:在实现该AOA算法时，至少需要两个APs来接收移动终端发送的信号。因此，通过信号的入射角和APs的位置可以很容易地得到APs与移动终端之间的线路。最简单的方法是利用这些线的交点来确定移动终端的位置。 与TOA/TDOA一样，AOA的定位精度易受环境变化的影响，如噪音、多径效应和非视距。 Frequency difference of arrival (FDOA):在定位过程中，FDOA主要利用运动目标的速度信息。由于AP和接收机之间的相对速度，接收机接收到的信号的频率和相位可能会随多普勒效应发生变化。在室内，AP和接收器之间的相对速度很小，因此使用FDOA进行室内定位是一个挑战。 被动定位适用于某些缺乏移动设备的特殊场合。 RSSI based利用目标移动时室内WiFi信号强度的变化直接对目标进行监测 CSI(信道状态信息) based与RSSI相比，CSI可以获得各子载波的频率响应，并提供细粒度的CSI。CSI包含各子载波的幅值和相位信息，在频域上提供了丰富的信息。RSSI容易受多径效应的影响，而CSI避免了这个问题。一般利用CSI中的振幅和相位信息 基于指纹的方法也被用于CSI，如DeepFi[70]。DeepFi的实现如下:在离线训练阶段，通过深度学习获得的所有权重产生DeepFi的指纹。在在线定位阶段，系统采用基于径向基函数的概率方法估计目标位置。 Open research issues about WiFi positioning","categories":[{"name":"论文笔记","slug":"论文笔记","permalink":"https://zhuoxueqaq.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"室内定位","slug":"室内定位","permalink":"https://zhuoxueqaq.github.io/tags/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D/"}]},{"title":"swift语法基础","slug":"swift语法基础","date":"2020-09-16T11:15:20.000Z","updated":"2020-09-17T11:28:58.726Z","comments":true,"path":"2020/09/16/swift语法基础/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/16/swift%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/","excerpt":"","text":"常量和变量12let constNumber = 100var variableNumber = 100 对不需要改变的值尽量声明为常量let 也可以使用类型注解： 1let constNumber:Int = 111 一般来说很少需要，swift可以在赋值的时候通过初值推断出常量或者变量的类型 输出常量和变量： 1234let constNumber:Int = 111print(constNumber)// 使用占位符print(&quot;const Number is \\(constNumber)&quot;) 基本数据类型整形整数类型包含默认整形Int以及无符号整形UInt**,少用UInt**。 整形有8,16,32,64位，一般来说不需要专门制定整形长度，用Int即可。 浮点型64位Double：高精度大存储 32位Float: 低精度小存储 都可以用的时候优先Float 布尔型12let orangesAreOrange = truelet turnipsAreDelicious = false 布尔类型不能使用非布尔值，否则报错 元组12let http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;) 可以把任意顺序、个数的类型组合成元组。 访问元组元素： 1234print(&quot;The status code is \\(http404Error.0)&quot;)// 输出“The status code is 404”print(&quot;The status message is \\(http404Error.1)&quot;)// 输出“The status message is Not Found” 定义元组的时候给单个元素命名： 1let http200Status = (statusCode: 200, description: &quot;OK&quot;) 作为函数返回值时，元组非常有用。 数值型字面量1234let decimalInteger = 17let binaryInteger = 0b10001 // 二进制的17let octalInteger = 0o21 // 八进制的17let hexadecimalInteger = 0x11 // 十六进制的17 十进制和十六进制指数： 12let a = 1.25e3 // 1.25*10^3let b = 0xFp2 // 15*2^2 类型转换1234567let three = 3let pointOneFourOneFiveNine = 0.14159let pi = Double(three) + pointOneFourOneFiveNine// pi 等于 3.14159，所以被推测为 Double 类型// 转成整形时，小数点后面被截断let integerpi = Int(pi) 类型别名12typealias myInt = Int32let maxMyInt = myInt.max 可选类型123456func convertStrToInt(arg: String) -&gt; Int? &#123; let res = Int(arg) return res&#125;print(convertStrToInt(arg: &quot;123&quot;))print(convertStrToInt(arg: &quot;1qq&quot;)) Int?代表可选类型。该函数试图将输入的字符串转换为整形，但是不是所有字符串都可以转换。当输入无法转换的字符串时，该函数返回nil，代表没有值（值缺失），类似于Javascript中的null。当确定 nil只能赋值给可选类型 1234567var serverResponseCode: Int? = 404// serverResponseCode 包含一个可选的 Int 值 404serverResponseCode = nil// serverResponseCode 现在不包含值var surveyAnswer: String?// surveyAnswer 被自动设置为 nilvar invalidNil:Int = nil //非法 可选绑定使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。 123456if let actualNumber = Int(possibleNumber) &#123; print(&quot;\\&#x27;\\(possibleNumber)\\&#x27; has an integer value of \\(actualNumber)&quot;)&#125; else &#123; print(&quot;\\&#x27;\\(possibleNumber)\\&#x27; could not be converted to an integer&quot;)&#125;// 输出“&#x27;123&#x27; has an integer value of 123” 上述例子中，当possibleNumber能转换为整形时，就将其转换后的值赋给新创建的actualNumber变量。 可以把多个可选绑定以及布尔条件放在一个if中，用逗号隔开就行 123if let a = Int(&quot;43&quot;), let b = Int(&quot;44&quot;), let c = Int(&quot;45&quot;), a &lt; b &amp;&amp; b &lt; c &#123; print(&quot;\\(a) &lt; \\(b) &lt; \\(c)&quot;) &#125; 隐式解析可选类型当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别： 12345let possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! // 需要感叹号来获取值let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString // 不需要感叹号 如果一个变量之后可能变成 nil 的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是 nil 的话，请使用普通可选类型。 错误处理123456789101112func makeASandwich() throws &#123; // ...&#125;do &#123; try makeASandwich() eatASandwich()&#125; catch SandwichError.outOfCleanDishes &#123; washDishes()&#125; catch SandwichError.missingIngredients(let ingredients) &#123; buyGroceries(ingredients)&#125;","categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"https://zhuoxueqaq.github.io/categories/IOS%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://zhuoxueqaq.github.io/tags/swift/"}]},{"title":"Typescript高级类型","slug":"Typescript高级类型","date":"2020-09-08T14:05:38.000Z","updated":"2020-09-09T13:52:39.006Z","comments":true,"path":"2020/09/08/Typescript高级类型/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/08/Typescript%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"交叉类型12345const mergeFunc = &lt;T, U&gt;(arg1: T, arg2: U): T &amp; U =&gt; &#123; let res = &#123;&#125; as T &amp; U res = Object.assign(arg1, arg2) return res&#125; 用 &amp; 声明，把多个类型合并成一个类型，合并后的类型同时有前面所有类型的成员 联合类型一般在函数参数中使用，比如要求某个参数可以是string和number类型，则可以声明为arg:string|number 类型保护1234567const getLength = (target: string | number) =&gt; &#123; if ((&lt;string&gt;target).length || (target as string).length === 0) &#123; return (&lt;string&gt;target).length &#125; else &#123; return target.toString.length &#125;&#125; 上面使用了类型断言，多次使用类型断言代码会变得较为复杂，可以使用类型保护简化。一旦检查过类型，就能在以后的每个分支清楚地知道变量的类型，比如下面的target 1234567891011// 定义函数实现类型保护function isString(value: string | number): value is string &#123; return typeof value === &#x27;string&#x27;&#125;const getLength = (target: string | number) =&gt; &#123; if (isString(target)) &#123; return target.length &#125; else &#123; return target.toString.length &#125;&#125; typeof类型保护将类型保护声明为函数较为复杂，Typescript中可以使用typeof关键字来检查类型： 1234567const getLength = (target: string | number) =&gt; &#123; if (typeof target === &#x27;string&#x27;) &#123; return target.length &#125; else if(typeof target !== &#x27;string&#x27;)&#123; return target.toString.length &#125;&#125; 这些* typeof类型保护*只有两种形式能被识别： typeof v === &quot;typename&quot;和 typeof v !== &quot;typename&quot;， 且&quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护，比如说： 12345678const getLength = (target: string | number) =&gt; &#123; if ((typeof target).includes(&#x27;string&#x27;)) &#123; // 类型“string | number”上不存在属性“length”。 return target.length &#125; else &#123; return target.toString.length &#125;&#125; 当target为字符串类型时，(typeof target).includes(&#39;string&#39;)返回true，但是typescript不会将其声明为类型保护 instanceof类型保护instanceof用来判断某个实例是不是某个类的实例 123456789101112131415class CreatedByClass1 &#123; public name: string = &#x27;zhuoxue&#x27;&#125;class CreatedByClass2 &#123; public age: number = 123&#125;function createClass() &#123; return Math.random() &lt; 0.5 ? new CreatedByClass1() : new CreatedByClass2()&#125;let item1 = createClass()if (item1 instanceof CreatedByClass1) &#123; console.log(item1.name)&#125; else &#123; console.log(item1.age)&#125; 可以为null的类型在默认情况下， null与 undefined可以赋值给任何类型，可以在配置文件中设置--strictNullChecks来开启严格检查，这样当声明一个变量时，它不再自动包含 null与 undefined类型，也可以手动指定包含null与 undefined的联合类型。需要注意的是 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数和可选属性在开启--strictNullChecks以后，可选参数和可选属性都会自动加上 | undefined 类型保护和类型断言由于可以为null的类型是通过联合类型实现，因此可以使用前面提到的类型保护和类型断言去除null。 123function f(sn: string | null): string &#123; return sn || &quot;default&quot;;&#125; 对于编译器无法识别的null，比如下面例子中的嵌套函数，可以使用类型断言手动指明某变量不为null： 12345678function getSplicedStr(num: number | null): string &#123; function getRes(prefix: string) &#123; // 这里用！或者？都可以，否则会由于num可能是null类型无法调用toFixed方法 return prefix + num!.toFixed.toString() &#125; num = num || 0.1 return getRes(&#x27;qaq&#x27;)&#125; 类型别名类型别名就是给一个类型起一个新名字，但是这不是创建一个新类型，比较类似于c++中的引用 12type TypeString = stringlet str1: TypeString = &#x27;qaq&#x27; 字面量类型字符串字面量类型使用字符串字面量类型可以让某字符串只能拥有固定的几个值。在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 123456type Direction = &#x27;north&#x27; | &#x27;east&#x27; | &#x27;south&#x27; | &#x27;west&#x27;function getDirectionFirstLetter(dir: Direction): string &#123; return dir.substring(0, 1)&#125;// 类型“&quot;qqq&quot;”的参数不能赋给类型“Direction”的参数。getDirectionFirstLetter(&#x27;qqq&#x27;) 数字字面量类型12345678910type Age = 1|2|3|4interface InfoInterface &#123; name: string age: Age&#125;const info1: InfoInterface = &#123; name: &#x27;qaq&#x27;, // 不能将类型“6”分配给类型“Age”。 age: 6&#125;","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript类","slug":"Typescript类","date":"2020-09-07T14:56:48.000Z","updated":"2020-09-09T14:07:21.473Z","comments":true,"path":"2020/09/07/Typescript类/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/07/Typescript%E7%B1%BB/","excerpt":"","text":"定义类123456789101112class Point&#123; public x: number public y: number constructor(x:number,y:number)&#123; this.x = x this.y = y &#125; printPoint() &#123; return `($&#123;this.x&#125;,$&#123;this.y&#125;)` &#125;&#125;let p1 = new Point(1,1) 其中constructor是构造函数，语法和c++,java都类似 类的继承1234567891011121314151617181920212223class Point&#123; public x: number public y: number constructor(x:number,y:number)&#123; this.x = x this.y = y &#125; printPoint() &#123; return `($&#123;this.x&#125;,$&#123;this.y&#125;)` &#125;&#125;class ThreeDPoint extends Point &#123; public z: number constructor(x:number,y:number,z:number) &#123; super(x,y) this.z = z &#125; printPoint() &#123; console.log(`($&#123;super.x&#125;,$&#123;super.y&#125;,$&#123;this.z&#125;)`) &#125;&#125;let p2 = new ThreeDPoint(1,1,1) 其中super指向其父类对象Point。声明子类的构造函数时，要先调用super()函数，可以理解成先调用父类的构造函数，然后再给子类新增成员初始化。 public，private和protected修饰符类似于c++等高级语言，typescript引入了这三个修饰符来规定成员的访问属性。 其中public表示该成员可以在类中，子类中以及类外自由访问。 private表示该成员为私有，只能在声明该成员的类中访问，无法在派生类类中（派生类类的构造函数可以初始化该成员，但是无法访问）以及类外访问 protected代表保护成员，保护成员可以在当前类以及派生类中访问（父类中需要继承给子类并使用的成员应声明为protected），类外无法访问 存取器在typescript中定义类时，可以定义get(设置属性值)和set(访问属性值)函数。 1234567891011121314151617class Point&#123; public x: number public y: number constructor(x:number,y:number)&#123; this.x = x this.y = y &#125; get nowPoint() &#123; return `($&#123;this.x&#125;,$&#123;this.y&#125;)` &#125; set changePoint(arg1:number,arg2:number) &#123; this.x = arg1 this.y = arg2 console.log(`($&#123;this.x&#125;,$&#123;this.y&#125;)`) &#125;&#125;let p1 = new Point(1,1) 静态属性typescript的静态属性和c++中类似，用static声明。静态成员和函数不属于实例化的某个对象，而是属于类本身。 1234567891011121314151617class User &#123; name: string password: string static count: number = 0 constructor(name: string, password: string) &#123; this.name = name this.password = password count += 1 &#125; static getUserCount &#123; rerturn User.count &#125;&#125;let user1 = new User(&#x27;123&#x27;,&#x27;123&#x27;)console.log(User.count)let user2 = new User(&#x27;123&#x27;,&#x27;123&#x27;)console.log(User.count) 抽象类抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法 12345678910111213141516abstract class User &#123; constructor(public name: string, public password: string) &#123; &#125; abstract printUserMessage(): void&#125;class Student extends User &#123; constructor(public name: string, public password: string, public type: string) &#123; super(name, password) &#125; printUserMessage() &#123; console.log(`User type: $&#123;this.type&#125;`) &#125;&#125;let s1 = new Student(&#x27;zhuoxue&#x27;, &#x27;123&#x27;, &#x27;student&#x27;)s1.printUserMessage() 在抽象基类的任意派生类中，从抽象基类继承的抽象方法必须重写","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript泛型","slug":"Typescript泛型","date":"2020-09-03T09:58:27.000Z","updated":"2020-09-03T14:01:25.983Z","comments":true,"path":"2020/09/03/Typescript泛型/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/09/03/Typescript%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 泛型的简单例子12345678910const getArray = &lt;T&gt;(value: T, times: number = 5): T[] =&gt; &#123; // 返回一个有times个值为value的数组 return new Array(times).fill(value)&#125;// map函数的作用是对数组中的每一个数据调用一个回调函数，并返回改变后的数组。这里把数组中所有元素变成字符串let arr = getArray&lt;number&gt;(123, 4).map((item) =&gt; item.toString())console.log(arr) 个人理解：泛型类似于c++中的函数模板 使用多个泛型参数1234567891011// 使用多个泛型参数const getArray1 = &lt;T, U&gt;(param1: T, param2: U, count: number): [T, U][] =&gt; &#123; return new Array(count).fill([param1, param2])&#125;let tup1 = getArray1(&#x27;user&#x27;, 123, 3)tup1.forEach((item) =&gt; &#123; console.log(item[0]) console.log(item[1])&#125;) 在类型别名中使用泛型1234type GetArray = &lt;T&gt;(arg: T, times: number) =&gt; T[]let getArray3: GetArray = (arg: any, times: number) =&gt; &#123; return new Array(times).fill(arg)&#125; 在接口中使用泛型1234interface GetArray&lt;T&gt; &#123; (arg: T, timea: number): T[], array: T[]&#125; 泛型约束简单来说，泛型约束就是让传入的泛型参数符合一定条件。 1234type GetLength = &lt;T&gt;(arg: T) =&gt; numberlet getLength = (arg: any) =&gt; &#123; return arg.length&#125; 上面的例子当传入没有length属性的例子时就会报错。为了限制函数处理任意带有length的属性，我们可以定义一个接口来描述该条件，并让泛型T继承该接口以满足约束 12345678interface ValueWithLength &#123; length: number&#125;type GetLength = &lt;T extends ValueWithLength&gt;(arg: T) =&gt; numberlet getLength = (arg: any) =&gt; &#123; return arg.length&#125; 在泛型约束中使用类型参数123456789101112const getProperty = &lt;T, K extends keyof T&gt;(Obj: T, key: K) =&gt; &#123; return Obj[key]&#125;const obj1 = &#123; a: &#x27;1&#x27;, b: &#x27;2&#x27;, c: &#x27;3&#x27;,&#125;getProperty(obj1, &#x27;d&#x27;) // 类型“&quot;d&quot;”的参数不能赋给类型“&quot;a&quot; | &quot;b&quot; | &quot;c&quot;”的参数。getProperty(obj1, &#x27;a&#x27;) // 1 在上面的例子中，当函数试图传入obj1不存在的索引时，会提示错误，保证当想从对象中获取某个属性对应的值时，该属性一定存在于对象中","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript开发环境搭建","slug":"Typescript开发环境搭建","date":"2020-08-31T12:36:38.000Z","updated":"2020-08-31T16:43:07.917Z","comments":true,"path":"2020/08/31/Typescript开发环境搭建/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/31/Typescript%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"打开vscode，进入待创建项目的根目录文件夹，在vscode的终端进行操作 使用npm初始化项目，生成package.json文件 1npm init -y 全局安装typescript 1npm install typescript -g 初始化，生成tsconfig.json文件 1tsc --init 根目录下创建src文件夹，在src下创建index.ts，并编译 1tsc ./src/index.ts 使用webpack工具。安装依赖包： 1npm i webpack webpack-cli webpack-dev-server -D 在配置webpack时，要区分开发环境和生产环境，为了让项目便于维护，可以开发环境配置、生产环境配置和公共配置分开书写，最后通过插件合并 在根目录下创建build文件夹，存放所有的配置文件，创建四个配置文件：webpack.base.config.js,webpack.config.js,webpack.dev.config.js,webpack.pro.config.js 编写开发环境配置文件webpack.base.config.js 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#x27;./src/index.ts&#x27;, output: &#123; filename: &#x27;app.js&#x27; &#125;, resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;] &#125;, module: &#123; rules: [ &#123; test: /\\.tsx?$/i, use: [&#123; loader: &#x27;ts-loader&#x27; &#125;], exclude: /node_modules/ &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/tpl/index.html&#x27; &#125;) ]&#125; 其中entry为项目的入口文件，output为输出文件，resolve代表可支持的文件拓展名。module规定了对指定后缀文件的处理方法，其中test用正则表达式匹配文件后缀，loader则是webpack加载各种资源文件使用的加载器，exclude则是排除指定目录的文件。插件HtmlWebpackPlugin可以帮我们生成网站的首页 接下来安装配置文件中相关依赖： 1npm install ts-loader typescript html-webpack-plugin -D 然后编写index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;app&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 编写开发环境配置文件webpack.dev.config.js: 123module.exports = &#123; devtool: &#x27;cheap-module-eval-source-map&#x27;&#125; 编写生产环境配置文件webpack.pro.config.js： 1234567const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123; plugins: [ new CleanWebpackPlugin() ]&#125; 并安装依赖包，这个包可以在每次成功构建项目之后清除一些无用的文件 1npm i clean-webpack-plugin -D 编写所有配置文件的入口配置文件webpack.config.js 123456const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)const baseConfig = require(&#x27;./webpack.base.config&#x27;)const devConfig = require(&#x27;./webpack.dev.config&#x27;)const proConfig = require(&#x27;./webpack.pro.config&#x27;)let config = process.NODE_ENV === &#x27;development&#x27; ? devConfig : proConfigmodule.exports = merge(baseConfig, config) 这里需要用npm安装插件webpack-merge，作用是把两个插件合并。该文件首先引入三个配置文件，然后定义变量config判断当前的环境变量，若是开发环境就选择开发环境配置，否则选择生产环境配置，最后合并配置文件 修改npm脚本文件package.json，如下： 123456789101112131415161718192021222324&#123; &quot;name&quot;: &quot;typescript_learning&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;./src/index.ts&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack-dev-server --mode=development --config ./build/webpack.config.js&quot;, &quot;build&quot;: &quot;webpack --mode=production --config ./build/webpack.config.js&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;clean-webpack-plugin&quot;: &quot;^3.0.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^4.4.1&quot;, &quot;ts-loader&quot;: &quot;^8.0.3&quot;, &quot;typescript&quot;: &quot;^4.0.2&quot;, &quot;webpack&quot;: &quot;^4.44.1&quot;, &quot;webpack-cli&quot;: &quot;^3.3.12&quot;, &quot;webpack-dev-server&quot;: &quot;^3.11.0&quot;, &quot;webpack-merge&quot;: &quot;^5.1.3&quot; &#125;&#125; 这里首先修改了name，令其不等于typescript，否则编译出错；接下来修改项目入口main；然后编写启动开发环境的命令start：使用webpack-dev-server 并指定为development开发模式，再指明配置文件目录； 然后就可以启动本地项目了： 123456npm start...i ｢wdm｣: Compiled successfully.i ｢wdm｣: Compiling...Version: webpack 4.44.1显示如下即编译成功，然后就可以在本地8080端口查看页面index.html了 接下来使用webpack编写构建生产环境的命令build 然后运行 1npn run build 打包以后，index.ts的内容会被整合到app.js中，并且会在index.html里引入app.js 到此基本结束。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"Typescript接口","slug":"Typescript接口","date":"2020-08-30T10:24:58.000Z","updated":"2020-08-31T11:21:24.161Z","comments":true,"path":"2020/08/30/Typescript接口/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/30/Typescript%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。 接口实例12345678910111213interface User &#123; userName: string, passWord: string&#125;function printUser(UserObj: User) &#123; let userMessege: string = `username: $&#123;UserObj.userName&#125;, password: $&#123;UserObj.passWord&#125;`; alert(userMessege);&#125;let myUser = &#123; userName: &#x27;zhuoxue&#x27;, passWord: &#x27;123&#x27;&#125;printUser(myUser); 可选接口 用？表示，代表实例化时该属性可传可不传 1234567891011121314151617interface User &#123; userName: string, passWord: string, age?: number&#125;function printUser(UserObj: User) &#123; let userMessege: string = `username: $&#123;UserObj.userName&#125;, password: $&#123;UserObj.passWord&#125;`; if(UserObj.age)&#123; userMessege += `, age:$&#123;UserObj.age&#125;`; &#125; alert(userMessege);&#125;let myUser = &#123; userName: &#x27;zhuoxue&#x27;, passWord: &#x27;123&#x27;&#125;printUser(myUser); 接口的只读属性（Readonly properties） readonly声明为只读。只读属性只能在初次实例化的时候传值，此后不能修改 123456interface Point &#123; readonly x: number, readonly y: number&#125;let p1: Point = &#123;x:10, y:10&#125;;p1.x = 15; // Cannot assign to &#x27;x&#x27; because it is a read-only property. 此外，Typescript拥有只读数组类型ReadonlyArray，该数组初始化后无法进行修改。可以使用普通数组来初始化只读数组，反之则不能，但可以使用type assertion操作来进行反向覆盖 123456let a: number[] = [1,2,3,4];let b: ReadonlyArray&lt;number&gt; = a;a = b; // The type &#x27;readonly number[]&#x27; is &#x27;readonly&#x27; and cannot be assigned to the mutable type &#x27;number[]&#x27;a[0] = 12;b[0] = 12; // Index signature in type &#x27;readonly number[]&#x27; only permits reading.a = b as number[] //type assertion Readonly和const 作用相似，使用场景不同。一般来说声明变量时使用const，而声明属性时用readonly 用接口描述函数类型下面是一个实例，类似于一个只有参数列表和返回值的函数声明。 接下来可以创建函数类型的变量，并分配对应类型的函数值，相应的值的参数列表和返回值需要一致，而参数名可不同 123456789101112131415interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string): boolean &#123; return src.search(subString)&gt;-1;&#125;// 也可mySearch = function(src: string, sub: string): boolean &#123; return src.search(sub)&gt;-1;&#125;// 返回值类型不同，报错mySearch = function(src: string, sub: string): boolean &#123; return src.search(sub); // Type &#x27;(src: string, sub: string) =&gt; string&#x27; is not assignable to type &#x27;SearchFunc&#x27;. Type &#x27;string&#x27; is not assignable to type &#x27;boolean&#x27;.&#125; 可索引类型（Indexable Types）有时我们想让我们对象支持向数组那样按照数字下标来存取数据，有时我们会想创建一个”字典”对象来存取任意的 “key/value” 对应关系。这两种情况就需要声明索引类型。区别在于索引本身的类型是数字还是字符串。 1234567891011121314interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray = [&quot;zhuoxue&quot;, &quot;qaq&quot;];let myStr: string = myArray[0];interface UserMap &#123; [index: string]: string;&#125;let myUserMap: UserMap = &#123; &quot;zhuoxue&quot;: &#x27;123&#x27;, &quot;qaq&quot;: &#x27;123&#x27;&#125;let pwd1: string = myUserMap[&#x27;zhuoxue&#x27;]; 可以同时支持两种索引，但是字符串索引对应值的类型必须是数字索引对应值的超集 123456789101112131415interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;interface NotOkay &#123; [x: number]: Animal, // Numeric index type &#x27;Animal&#x27; is not assignable to string index type &#x27;Dog&#x27;. [x: string]: Dog&#125;interface Okay &#123; [x: number]: string, [x: string]: string&#125; 此外，也可以将索引签名声明为只读，防止对应的值被修改。 类类型（Class Types）接口实现接口最常见的用法之一就是用来显式的约束类以满足特定的协定。 1234567interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); constructor(h: number, m: number) &#123;&#125;&#125; 此外，我们可以描述用类实现的接口中的方法 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date): void;&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date(); setTime(d: Date) &#123; this.currentTime = d; &#125; constructor(h: number, m: number) &#123;&#125;&#125;","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"TypeScript函数","slug":"TypeScript函数","date":"2020-08-29T10:18:01.000Z","updated":"2020-09-03T12:37:35.614Z","comments":true,"path":"2020/08/29/TypeScript函数/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/29/TypeScript%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数——定义函数12345function getPassword(userName: string): string &#123; // 语句 return password;&#125;let pwd: string = getPassword(&#x27;zhuoxue&#x27;); 和js不同，ts函数的形参要指定类型，且实参和形参要一一对应 函数——可选参数和默认参数12345678// 可选参数,调用时对应实参可传可不传function getPassword(userName?: string): string &#123; //&#125;// 默认参数，更常用function setPassword(userName: string, passWord: string=&#x27;123456&#x27;): void&#123; //&#125; 理解类型别名12type isString = stringlet str: isString = &#x27;zhuoxueqaq&#x27; 使用类型别名定义函数类型12type Add = (x: number, y: number) =&gt; numberlet add4: Add = (arg1: number, arg2: number) =&gt; arg1 + arg2 函数——剩余参数12345678function add(a: number, b: number, ...c: number[]): void &#123; let resNum: number = a + b; for (let num of c) &#123; resNum += num; &#125; alert(resNum);&#125;add(1, 2, 3, 4, 5, 65, 7); 剩余参数需排在参数列表的最后，且必须为数组 函数重载123456789101112// 声明方法重载的定义，不实现function handleData(x: string): string[]function handleData(x: number): number[]// 声明一个any类型的重载定义，并根据具体参数和返回类型来实现方法function handleData(x: any): any &#123; if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;) &#125; else &#123; return x.toString().split(&#x27;&#x27;).map((item: any) =&gt; Number(item)) &#125;&#125;console.log(handleData(123))","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"TypeScript基本数据类型","slug":"ts基本数据类型","date":"2020-08-28T12:48:16.000Z","updated":"2020-09-09T08:25:45.139Z","comments":true,"path":"2020/08/28/ts基本数据类型/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/28/ts%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"变量 定义变量 1let userName:string = &#x27;zhuoxue&#x27;; 在ts中，对指定了类型的变量只能设置相同类型的值，和js不同 12let userName:string = &#x27;zhuoxue&#x27;;userName = 233; //类型非法 常用数据类型 字符串 1let userName: string = &#x27;zhuoxue&#x27;; 模板字符串 123let fullName: string = `zhuoxue`;let age: number = 21;let sentence: string = `My name is $&#123;fullName&#125;. I&#x27;m $&#123;age&#125; years old`; 模板字符串用反引号``表示，并且可以使用占位符${expr}进行嵌入 数值类型 12let testCount: number = 123;testCount = 123.45; 布尔型 123let isUser: boolean = true;isUser = false;// 要注意的是ts不能像js一样把true等价为1，false等价为0 undefined和null 数组 123456// 方式1let userList: string[] = [&#x27;qqq&#x27;,&#x27;www&#x27;];// 方式2：泛型语法let userList: Array&lt;string&gt; = [&#x27;qaq&#x27;,&#x27;qwq&#x27;];// 与js不同，ts定义数组要指定其中元素的数据类型，里面只能放相同类型的元素// 数组长度没有限制 元组 123let tup1: [string, number, bollean] = [&#x27;喜欢&#x27;, 520, true];alert(tup1[0]);console.log(tup1.length); 枚举 123456789101112131415161718192021222324252627enum GunType &#123; m416 = 1, ak47 = 2, goza = 3&#125;// 默认枚举值从0开始enum GunType &#123; m416, //0 ak47, //1 goza //2&#125;// 使用枚举对象let userGun: GunType = GunType.m416;// 字符串枚举enum Message &#123; Error =&#x27;error&#x27;, Success = &#x27;success&#x27;, Failed = Error,&#125;// 异构枚举enum Result &#123; Error = 0, Success = &#x27;success&#x27;,&#125; any any代表任意类型，一般在获取dom时使用。此外，接受用户输入或者第三方代码库时，尚未确定返回什么类型的值，也可使用any类型 12// 示例let txtName: any = document.getElementById(&#x27;txtN&#x27;); any类型牺牲了类型安全性换来了便捷性，而类型安全是typescript的一个主要特点，因此在不必要时应避免使用any void 无类型，一般在无返回值的函数中使用 never 不存在的值的类型，常用作为抛出异常或者无限循环的函数的返回类型 12345678function test():never &#123; while(true)&#123; &#125;&#125;function test1():never &#123; throw new Error(&#x27;error&#x27;);&#125; never类型为ts中的底部类型，所有类型都是never类型的父类，所以never类型值可以赋给任意类型的变量 类型断言1234567const getLength = (target: string | number) =&gt; &#123; if (target.length || target.length === 0) &#123; return target.length &#125; else &#123; return target.toString.length &#125;&#125; 上面的代码会报错，因为当target为数字时，数字是没有长度属性的，可以使用类型断言解决这个问题 123456789const getLength = (target: string | number) =&gt; &#123; // 类型断言的两种写法，在jss中只能使用第二种写法 if ((&lt;string&gt;target).length || (target as string).length === 0) &#123; return (&lt;string&gt;target).length &#125; else &#123; return target.toString.length &#125; &#125; 表示变量的取值可以为多种类型中的一种 12let userName: string | null = prompt(&#x27;input username:&#x27;);console.log(&#x27;hello&#x27; + userName); 关于let和const 在ES6之前，一般用var来声明变量。由于JS只有函数作用于和全局作用域，没有块级作用域，所以&#123;&#125;限定不了var声明变量的访问范围。 let则可以声明块级作用域的变量，且let变量不存在变量提升（声明完才能使用），也不能重复声明。 123456&#123; var a = 1; let b = 1;&#125;console.log(a); // 1console.log(b); // Uncaught ReferenceError: i is not defined let相比var更安全可控 const是let的增强，使用const定义的变量不能再被赋值，但其定义变量的内部属性可以修改 1234567891011const user = &#123; name: &#x27;zhuoxue&#x27;, pwd: &#x27;123&#x27;&#125;// 错误user = &#123; name: &#x27;zhuoxueqaq&#x27;, pwd: &#x27;123456&#x27;&#125;// 正确user.name = &#x27;zhuoxueqaq&#x27;; 对不需要修改的变量建议用const let。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"}]},{"title":"使用hexo和github搭建博客","slug":"使用hexo和github搭建博客","date":"2020-08-28T06:33:43.000Z","updated":"2020-08-29T15:28:31.894Z","comments":true,"path":"2020/08/28/使用hexo和github搭建博客/","link":"","permalink":"https://zhuoxueqaq.github.io/2020/08/28/%E4%BD%BF%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"安装和使用hexo安装hexo 安装node.js（内置npm） 全局安装cnpm： 1cnpm：npm install -g cnpm 安装hexo并验证安装： 12hexo：cnpm install -g hexohexo -v 使用hexo搭建博客 在目录文件夹git bash，并初始化hexo项目： 1hexo init 新建博客（新建的md文件存储在./source/_post下）： 1hexo n &quot;博客标题&quot; 生成hexo项目： 1hexo g 本地启动项目： 1hexo s 清空配置： 1hexo clean 将博客在github上部署建立github存储库 登录github账号，新建存储库。存储库名称为昵称.github.io 修改GitHub Pages配置，类型为master，并保存 选择任意主题即可 部署 修改项目根目录下的_config.yml文件中的Deployment选项： 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/ZhuoxueQAQ/ZhuoxueQAQ.github.io.git branch: master 要注意的是键的后面要有一个空格，否则无效 安装git部署插件： 1cnpm install --save hexo-deployer-git 安装完成后使用hexo清除历史配置，生成项目，并部署： 123hexo cleanhexo ghexo d 访问ZhuoxueQAQ.github.io即可。","categories":[{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zhuoxueqaq.github.io/tags/hexo/"}]}],"categories":[{"name":"IOS开发","slug":"IOS开发","permalink":"https://zhuoxueqaq.github.io/categories/IOS%E5%BC%80%E5%8F%91/"},{"name":"论文笔记","slug":"论文笔记","permalink":"https://zhuoxueqaq.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"前端学习","slug":"前端学习","permalink":"https://zhuoxueqaq.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"swift","slug":"swift","permalink":"https://zhuoxueqaq.github.io/tags/swift/"},{"name":"室内定位","slug":"室内定位","permalink":"https://zhuoxueqaq.github.io/tags/%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D/"},{"name":"typescript","slug":"typescript","permalink":"https://zhuoxueqaq.github.io/tags/typescript/"},{"name":"hexo","slug":"hexo","permalink":"https://zhuoxueqaq.github.io/tags/hexo/"}]}